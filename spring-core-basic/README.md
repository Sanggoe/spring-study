# 스프링 코어 핵심 원리 - 기본편

<br/>

## 스프링이란?

### 스프링 역사

쉽게 말해, 복잡하고 무겁고 어렵고 느리고 비싼 EJB에 빡쳐서.. '내가 짜도 이거보단 잘 만들겠다'라며 천재 개발자들이 뭉쳐서 오픈소스로 만든 것이다!

<br/>

### 스프링 생태계

**필수**

* 스프링 프레임워크, 스프링 부트

**선택**

* 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드

<br/>

### 스프링 프레임워크

* 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
* 웹 기술 : 스프링 MVC, 스프링 WebFlux
* 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
* 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
* 테스트 : 스프링 기반 테스트 지원
* 언어 : 코틀린, 그루비
* 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용

<br/>

### 스프링부트

* 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
* 서버를 내장해서 사용!

<br/>

### 스프링이란?

* 스프링 DI 컨테이너 기술
* 스프링 프레임워크
* 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

<br/>

### 스프링의 진짜 핵심

* 스프링은 자바 언어 기반의 프레임워크
* 자바 언어 : **객체 지향 언어**
* 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
* 스프링은 **좋은 객체 지향** 애플리케이션을 개발할 수 있게 도와주는 프레임워크

<br/>

<br/>

<br/>

<hr/>

## 좋은 객체 지향 프로그래밍이란?

* 객체지향 : 추상화, 캡슐화, 상속, 다형성
* 객체지향 프로그래밍 : 명령어의 목록 시각이 아닌, 여러 독립된 단위인 '객체'의 모임으로 파악하는 관점. 각각의 객체는 메시지를 주고받고 데이터를 처리할 수 있다(협력). 유연하고 변경이 용이하다.
  * 다형성 Polymorphism

<br/>

### 다형성 실세계 비유

* 실세계와 객체지향 1:1 매칭은 X
* **역할**과 **구현**으로 나누어 본다.
* 예) 운전자 - 자동차 / 공연 무대 / 표준 인터페이스들 / 정렬 알고리즘 / 할인 정책 로직 등...

<br/>

* 운전자 역할
* 자동차 역할
  * (자동차 구현) K3 
  * (자동차 구현) 아반떼
  * (자동차 구현) 테슬라 모델3

자동차 구현을 바꿔도 운전자에는 전혀 영향을 주지 않는다. 새로운 자동차가 나와도 운전자는 상관 없는 것. 즉, 클라이언트에 영향을 주지 않고 새로운 기능을 제공할 수 있다는 것!

<br/>

### 역할과 구현을 분리

* **역할**과 **구현**으로 구분하면 **단순**해지고, **유연**해지며, 변경도 편리해진다.
* 장점
  * **클라이언트**는 대상 역할(인터페이스)만 알면 된다.
  * **클라이언트**는 구현 대상의 **내부 구조를 몰라도** 된다.
  * **클라이언트**는 구현 대상의 **내부 구조가 변경** 되어도 영향 받지 않는다.
  * **클라이언트**는 구현 **대상의 자체를 변경**해도 영향을 받지 않는다.

<br/>

**자바 언어 관점**

* 역할 = 인터페이스
* 구현 = 인터페이스를 구현한 클래스, 구현 객체
* 객체 설계시, **역할**과 **구현**을 명확히 분리
* 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

<br/>

### 객체의 협략이라는 관계부터 생각!

* 클라이언트 : request / 서버 : response
* 객체는 협력적이다. 혼자가 아니다. 서로 협력 관계를 가진다.

<br/>

### 자바 언어의 다형성

* 오버라이딩! 클래스 또는 메소드 재정의
* 호출 시, 오버라이딩 된 메서드가 실행된다.

<br/>

### 다형성의 본질

* 인터페이스를 구현한 객체 인스턴스를 **실행 시점**에 유연하게 변경할 수 있다.
* 다형성 본질 이해를 위해, 협력이라는 객체 사이 관계에서 시작해야 한다.
* **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다!**
  * 클라이언트가 요청한 것에 대해서, MemoryMemberRepository가 응답할 수도 있고, JdbcMemberRepository가 응답할 수도 있다.

<br/>

### 역할과 구현을 분리

**정리**

* 유연, 변경 용이
* 확장 가능 설계
* 클라이언트에 영향 주지 않는 변경 가능
* 인터페이스의 안정적 설계가 정말 중요

**한계**

* 역할(인터페이스) 자체가 변하면, 클라이언트와 서버 모두 큰 변경이 발생한다.
* 따라서 인터페이스를 안정적으로 잘 설계하는 것이 정말 중요하다.

<br/>

### 스프링과 객체 지향

* 객체 지향에서는 다형성이 가장 중요한 듯!
* 스프링은 다형성 극대화 해서 이용할 수 있게 도와준다.
* IoC, DI는 다형성을 활용해 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

<br/>

<br/>

<br/>

<hr/>

## SOLID

### 좋은 객체 지향 설계의 5가지 원칙

* SRP : 단일 책임 원칙 (simgle responsibility principle)
* OCP : 개방-폐쇄 원칙 (Open/closed principle)
* LSP : 리스코프 치환 원칙 (Liskov substitution principle)
* ISP : 인터페이스 분리 원칙 (Interface segregation principle)
* DIP : 의존관계 역전 원칙 (Depenency inversion principle)

<br/>

### SRP 단일 책임 원칙

**simgle responsibility principle**

* 한 클래스는 하나의 책임만 가져야 한다는 말인데, 그 '책임'이 모호하다. 클 수도, 작을 수도, 문맥 상황에 따라 다르다.
* **중요한 기준은 변경**. 변경시 파급 효과가 적으면 SRP를 잘 따른것.
  * 예) UI 변경, 객체 생성 및 사용을 분리

<br/>

### OCP 개방-폐쇄 원칙 ★

**Open/closed principle**

* **가장 중요한 원칙1!**
* 소프트웨어 요소는 **확장에는 열려** 있으나, **변경에는 닫혀** 있어야 한다.
* **다형성**을 활용해서!!
* 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현한다.
* 다만, 아래 **문제점**은 클라이언트 코드 변경이 되므로 위배되는 경우!

<br/>

**문제점**

* MemberService 클라이언트가 구현 클래스를 직접 선택

  ```java
  MemberRepository m = new MemoryMemberRepository(); // 기존 코드
  MemberRepository m = new JdbcMemberRepository(); // 변경 코드
  ```

* 구현 객체를 변경하려면 클라이언트의 코드를 변경해야 한다.

* 다형성을 사용했지만, OCP 원칙에 위배 되는 것!

* 이 문제를 해결하기 위해 객체 생성 및 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

  * 이제 여기서 DI, IoC 컨테이너 등 개념이 사용되는 것.

<br/>

### LSP 리스코프 치환 원칙

**Liskov substitution principle**

* 다형성에서 하위 클래스는 인터페이스의 규약을 지켜야 한다는 것!
* 구현체는 프로그램 정확성을 깨뜨리지 않으면서 인터페이스의 기능 의도에 맞게 구현해야 한다는 말이다.

<br/>

### ISP 인터페이스 분리 원칙

**Interface segregation principle**

* 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
  * 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
  * 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
  * 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
* 인터페이스가 명확해지고, 대체 가능성이 높아진다.
* 인터페이스도 기능을 맞게 적당한 크기로 적절히 쪼개는 것이 필요하다는 말.

<br/>

### DIP 의존관계 역전 원칙 ★

**Depenency inversion principle**

* **가장 중요한 원칙2!**

* 클라이언트 코드가 구현 클래스를 바라보지 말고, 인터페이스만 바라보라는 의미!

* 클라이언트는 인터페이스의 구현이 무엇인지 알 필요 없고, 역할(Role)에만 의존해야 한다!!

* 의존성 주입은 이 원칙을 따르는 방법중 하나다.

* 앞서 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.

  * MemberService 클라이언트가 구현 클래스를 직접 선택중

    ```java
    MemberRepository m = new MemoryMemberRepository(); // 구현체 직접 선택
    ```

    * **그 코드에 대해서 안다는 것**은, **의존한다는 것**이다.

  * DIP 위반!!

<br/>

### 정리

* 객체 지향의 핵심은 다형성
* But 다형성 만으로는 부품 갈아끼우듯 개발할 수 없고, 구현 객체 변경 시 클라이언트 코드도 함께 변경된다.
* 다형성 만으로는, OCP, DIP를 지킬 수 없다. 뭔가 더 필요하다!!

<br/>

<br/>

<br/>

<hr/>

## 객체지향 설계와 스프링

* **스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.**
  * DI(Dependency Injection) : 의존관계, 의존성 주입
  * DI 컨테이너 제공
* **클라이언트의 코드 변경 없이 기능 확장**! 쉽게 부품을 교체하듯이 개발

<br/>

### 정리

* 모든 설계에 **역할**, **구현** 분리 (운전자-자동차, 공연 예시 참고)
* 앱 설계도 공연을 설계하듯 배역만 정하고, 배우는 언제든 유연하게 변경할 수 있도록 만드는 것이 좋은 객체지향 설계이다. 이상적으로는, 모든 설계에 **인터페이스**를 부여하자.
  * 예를 들어, 모든 설계가 인터페이스이면 어떤 DB를 쓸지 어떤 구현을 쓸지 전혀 정해지지 않아 뭐든 교체해가며 만들 수 있는 것.

<br/>

**실무 고민**

* But 인터페이스를 도입하면 추상화라는 비용이 발생한다.
* 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링 해서 인터페이스를 도입하는 것도 방법

<br/>

<br/>

<br/>

<br/>

<br/>

